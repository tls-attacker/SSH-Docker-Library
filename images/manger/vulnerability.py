import binascii

from rsa import PrivateKey
from asyncssh import public_key

"""
This class is used in the patched files to make a server vulnerable to Manger's attack.
It consists of two parts:

The first part makes the server use the same transient public key in every RSA key exchange.

The second part interrupts the encrypted secret decryption in the RSA key-exchanges secret message
to do a raw decrypt and manually check if the first byte is 00, to be able to return a different error message.
This makes the server provide a Manger oracle.
"""

# Loads completely static transient public keys
# Set these to 'None' if you want fresh transient public keys on each restart
transient_key_2048 = public_key.read_private_key("server_keys/ssh_host_key")
transient_key_1024 = public_key.read_private_key("server_keys/rsa_1024")


# Generates static transient public keys or simply returns the existing ones
def get_static_transient_public_key(key_size):
    global transient_key_1024
    global transient_key_2048
    if key_size == 2048:
        if transient_key_2048 is None:
            transient_key_2048 = public_key.generate_private_key("ssh-rsa", key_size)
        return transient_key_2048
    if key_size == 1024:
        if transient_key_1024 is None:
            transient_key_1024 = public_key.generate_private_key("ssh-rsa", key_size)
        return transient_key_1024


# Checks if the first byte of an RSA key-exchange secret message is 0 and returns true if so
def first_byte_is_zero(transient_key, encrypted_key):
    # Convert asyncssh's private key to rsa package private key
    transient_key_in_der = transient_key.encode_pkcs8_private()[1]
    rsa_private_key = PrivateKey._load_pkcs1_der(transient_key_in_der)

    # Convert encrypted byte array to integer, so it can be used for decryption and decrypt
    encrypted_key_as_integer = int(binascii.hexlify(encrypted_key), 16)
    decrypted_integer = rsa_private_key.blinded_decrypt(encrypted_key_as_integer)
    decrypted_bytes = decrypted_integer.to_bytes(len(encrypted_key), "big")
    # print("Decrypted bytes: ")
    # print([x for x in decrypted_bytes])

    # now check if first byte is 00
    first_byte = decrypted_bytes[0]
    return first_byte == 0
